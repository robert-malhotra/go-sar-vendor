Repository Documentation
This document provides a comprehensive overview of the repository's structure and contents.
The first section, titled 'Directory/File Tree', displays the repository's hierarchy in a tree format.
In this section, directories and files are listed using tree branches to indicate their structure and relationships.
Following the tree representation, the 'File Content' section details the contents of each file in the repository.
Each file's content is introduced with a '[File Begins]' marker followed by the file's relative path,
and the content is displayed verbatim. The end of each file's content is marked with a '[File Ends]' marker.
This format ensures a clear and orderly presentation of both the structure and the detailed contents of the repository.

Directory/File Tree Begins -->

umbra/
├── umbra.go
└── umbra_test.go

<-- Directory/File Tree Ends

File Content Begin -->
[File Begins] umbra.go
package umbra

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"time"
)

// ImagingMode is a constrained string type for valid imaging modes
type ImagingMode string

const (
	SPOTLIGHT_MODE ImagingMode = "SPOTLIGHT" // only mode supported
)

type Client struct {
	HTTPClient *http.Client
	baseURL    *url.URL
}

type PointGeometry struct {
	Type        string    `json:"type"`
	Coordinates []float64 `json:"coordinates"`
}

type SpotlightConstraints struct {
	ImagingMode                    ImagingMode   `json:"imagingMode,omitempty"`
	Geometry                       PointGeometry `json:"geometry"`
	Polarization                   string        `json:"polarization,omitempty"`
	RangeResolutionMinMeters       float64       `json:"rangeResolutionMinMeters,omitempty"`
	MultilookFactor                int           `json:"multilookFactor,omitempty"`
	GrazingAngleMinDegrees         int           `json:"grazingAngleMinDegrees,omitempty"`
	GrazingAngleMaxDegrees         int           `json:"grazingAngleMaxDegrees,omitempty"`
	TargetAzimuthAngleStartDegrees int           `json:"targetAzimuthAngleStartDegrees,omitempty"`
	TargetAzimuthAngleEndDegrees   int           `json:"targetAzimuthAngleEndDegrees,omitempty"`
	SceneSize                      string        `json:"sceneSize,omitempty"`
}

type TaskingRequest struct {
	ImagingMode          ImagingMode          `json:"imagingMode,omitempty"`
	SpotlightConstraints SpotlightConstraints `json:"spotlightConstraints"`
	WindowStartAt        time.Time            `json:"windowStartAt"`
	WindowEndAt          time.Time            `json:"windowEndAt"`
}

type FeasibilityResponse struct {
	ID      string         `json:"id"`
	Status  string         `json:"status"`
	Request TaskingRequest `json:"feasibilityRequest"`
	Results []Opportunity  `json:"opportunities"`
}

type Opportunity struct {
	WindowStartAt                      time.Time `json:"windowStartAt"`
	WindowEndAt                        time.Time `json:"windowEndAt"`
	DurationSec                        int       `json:"durationSec"`
	GrazingAngleStartDegrees           float64   `json:"grazingAngleStartDegrees"`
	GrazingAngleEndDegrees             float64   `json:"grazingAngleEndDegrees"`
	TargetAzimuthAngleStartDegrees     float64   `json:"targetAzimuthAngleStartDegrees"`
	TargetAzimuthAngleEndDegrees       float64   `json:"targetAzimuthAngleEndDegrees"`
	SquintAngleStartDegrees            float64   `json:"squintAngleStartDegrees"`
	SquintAngleEndDegrees              float64   `json:"squintAngleEndDegrees"`
	SquintAngleEngineeringDegreesStart float64   `json:"squintAngleEngineeringDegreesStart"`
	SquintAngleEngineeringDegreesEnd   float64   `json:"squintAngleEngineeringDegreesEnd"`
	SlantRangeStartKm                  float64   `json:"slantRangeStartKm"`
	SlantRangeEndKm                    float64   `json:"slantRangeEndKm"`
	GroundRangeStartKm                 float64   `json:"groundRangeStartKm"`
	GroundRangeEndKm                   float64   `json:"groundRangeEndKm"`
	SatelliteId                        string    `json:"satelliteId"`
}

func NewClient(u string) (*Client, error) {
	baseURL, err := url.Parse(u)
	if err != nil {
		return nil, err
	}
	return &Client{
		HTTPClient: &http.Client{Timeout: 10 * time.Second},
		baseURL:    baseURL,
	}, nil
}

func (c *Client) doRequest(token, method string, url *url.URL, body io.Reader, expectedStatus int, result any) error {
	httpReq, err := http.NewRequest(method, url.String(), body)
	if err != nil {
		return fmt.Errorf("failed to create request: %w", err)
	}

	httpReq.Header.Set("Authorization", "Bearer "+token)
	httpReq.Header.Set("Accept", "application/json")
	if method == http.MethodPost {
		httpReq.Header.Set("Content-Type", "application/json")
	}

	resp, err := c.HTTPClient.Do(httpReq)
	if err != nil {
		return fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response body: %w", err)
	}

	if resp.StatusCode != expectedStatus {
		return fmt.Errorf("bad response status: %s – %s", resp.Status, respBody)
	}

	if err := json.Unmarshal(respBody, result); err != nil {
		return fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return nil
}

func (c *Client) CreateFeasibility(token string, req *TaskingRequest) (*FeasibilityResponse, error) {
	jsonData, err := json.Marshal(req)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	var result FeasibilityResponse
	err = c.doRequest(token, http.MethodPost, c.baseURL.JoinPath("tasking", "feasibilities"),
		bytes.NewBuffer(jsonData), http.StatusCreated, &result)
	if err != nil {
		return nil, err
	}
	return &result, nil
}

func (c *Client) GetFeasibility(token string, id string) (*FeasibilityResponse, error) {
	var result FeasibilityResponse
	err := c.doRequest(token, http.MethodGet, c.baseURL.JoinPath("tasking", "feasibilities", id),
		nil, http.StatusOK, &result)
	if err != nil {
		return nil, err
	}
	return &result, nil
}

[File Ends] umbra.go

[File Begins] umbra_test.go
package umbra_test

import (
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	"github.com/robert.malhotra/umbra-client/pkg/umbra"
)

func setupMockServer(t *testing.T, expectedMethod, expectedPath string, expectedStatus int, response any) *httptest.Server {
	return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.Method != expectedMethod {
			t.Fatalf("Expected method %s, got %s", expectedMethod, r.Method)
		}
		if !strings.HasSuffix(r.URL.Path, expectedPath) {
			t.Fatalf("Expected path suffix %s, got %s", expectedPath, r.URL.Path)
		}
		w.WriteHeader(expectedStatus)
		_ = json.NewEncoder(w).Encode(response)
	}))
}

func TestCreateFeasibility(t *testing.T) {

	req := &umbra.TaskingRequest{
		ImagingMode: umbra.SPOTLIGHT_MODE,
		SpotlightConstraints: umbra.SpotlightConstraints{
			Geometry: umbra.PointGeometry{
				Type:        "Point",
				Coordinates: []float64{12.34, 56.78},
			},
		},
		WindowStartAt: time.Now(),
		WindowEndAt:   time.Now().Add(30 * time.Minute),
	}

	mockResp := umbra.FeasibilityResponse{
		ID:      "mock-id",
		Status:  "CREATED",
		Request: *req,
	}

	server := setupMockServer(t, http.MethodPost, "/tasking/feasibilities", http.StatusCreated, mockResp)
	defer server.Close()

	client, err := umbra.NewClient(server.URL)
	if err != nil {
		t.Fatalf("failed to create client: %v", err)
	}

	resp, err := client.CreateFeasibility("test-token", req)
	if err != nil {
		t.Fatalf("CreateFeasibility failed: %v", err)
	}

	if resp.ID != "mock-id" || resp.Status != "CREATED" {
		t.Errorf("Unexpected response: %+v", resp)
	}
}

func TestGetFeasibility(t *testing.T) {
	mockResp := umbra.FeasibilityResponse{
		ID:     "mock-id",
		Status: "PROCESSING",
	}

	server := setupMockServer(t, http.MethodGet, "/tasking/feasibilities/mock-id", http.StatusOK, mockResp)
	defer server.Close()

	client, err := umbra.NewClient(server.URL)
	if err != nil {
		t.Fatalf("failed to create client: %v", err)
	}

	resp, err := client.GetFeasibility("test-token", "mock-id")
	if err != nil {
		t.Fatalf("GetFeasibility failed: %v", err)
	}

	if resp.ID != "mock-id" || resp.Status != "PROCESSING" {
		t.Errorf("Unexpected response: %+v", resp)
	}
}

[File Ends] umbra_test.go


<-- File Content Ends

